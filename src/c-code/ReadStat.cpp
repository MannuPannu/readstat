#include "com_control_ReadStat.h"   // this header file was generated by javah

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <list>
#include <string>
#include <dirent.h> 

#include "polystatistics.h"

using namespace std;

jobject createJavaProcessStatObject(char *fileName, polystatistics *polyS, JNIEnv *env);
char* getPolyDir();
list <string> getProcessFiles(char *dir);

/* Program that reads the memory files in the .polyml directory
   and outputs all the data to the terminal */

JNIEXPORT void JNICALL Java_com_control_ReadStat_getStatistics (JNIEnv *env, jobject obj)
{
  int remMapFd = -1;
  char remMapFileName[100];
  int pageSize = getpagesize();
  size_t memSize = (sizeof(polystatistics) + pageSize-1) & ~(pageSize-1);

  polystatistics *polyS;

  jobject returnObject;

  //Get the statistic files for each poly/ML process
  list <string> entryList = getProcessFiles(getPolyDir());

  //Retrieves all the file names for each poly ml process that are running
  //  Returns: List of the file names
  
  list<string>::iterator it;
  it = entryList.begin();
  int numberOfFiles = (int)entryList.size();

  //Create the array that will contain all statistics objects
  printf("Try to find class ProcessStat");
  jclass statClass = env->FindClass("com/model/ProcessStat");

  if (statClass == 0) printf("NULL RETURNED from statClass in FindClass()\n");

  jobjectArray statArray = env->NewObjectArray(numberOfFiles, statClass, NULL);
  int count = 0;

  while(it != entryList.end())
    {
      string fileName = *it;
      char *fileNamePtr;
      char *mapFileName;
      fileNamePtr = new char [fileName.size()+1];
      strcpy(fileNamePtr, fileName.c_str());

      mapFileName = (char*)malloc(strlen(getPolyDir() + 100));
      sprintf (mapFileName, "%s%s", getPolyDir(), fileNamePtr);

      remMapFd = open(mapFileName, O_RDONLY);

      polyS = (polystatistics*)mmap(0, //adress
				    memSize, // Length to map
				    PROT_READ, //protect
				    MAP_PRIVATE, //flags
				    remMapFd, //filedest
				    0); // offset
      if (polyS == MAP_FAILED)
	{
	  close(remMapFd);
	  printf("Map failed\n");
	}

      printf("%s", fileNamePtr);
      returnObject = createJavaProcessStatObject(fileNamePtr, polyS, env);

      it++;

      //Add it to the processStat array
      env->SetObjectArrayElement(statArray, count, returnObject);

      count++;
    }

    //Close the mapping
    munmap(polyS, memSize);
    close(remMapFd);

    //Create an array object to return
    jclass arrayClass = env->FindClass("com/model/Statistics");

    if (arrayClass == 0) printf("NULL RETURNED from arrayClass in FindClass()\n");

    printf("Sizeof arrayClass = %d\n", (int)sizeof(arrayClass) );

    jmethodID constructorMethodID;

    //get the constructor
    constructorMethodID = env->GetMethodID(arrayClass,
					      "<init>","([Lcom/model/Statistics;I)V");

    printf("Created Statistics object\n");
    jobject statObj = NULL;

    //Create new Statistics object
    //statObj = env->NewObject(arrayClass, constructorMethodID, statArray, count);

    //    return statObj;
}

jobject createJavaProcessStatObject(char *fileNamePtr, polystatistics *polyS, JNIEnv *env)
{
    //Create the psCounters java array
    jlongArray psCounters;
    psCounters = env->NewLongArray(8);
    
    if (psCounters == NULL) {
      printf("psCounters -> java array failed\n");
      }
        
    jlong temp[8];
    for(int i = 0; i < 8; i++)
      {
	temp[i] = polyS->psCounters[i];
      }

    env->SetLongArrayRegion(psCounters, 0, 8, temp); 

    //Create the psSizes java array
    jintArray psSizes;
    psSizes = env->NewIntArray(N_PS_SIZES);

    if(psSizes == NULL) {
      printf("psSizes -> java array failed\n");
    }      

    jint tempInt[N_PS_SIZES];

    for(int i = 0; i < N_PS_SIZES; i++)
      {
	tempInt[i] = polyS->psSizes[i];
      }

    env->SetIntArrayRegion(psSizes, 0, N_PS_SIZES, tempInt); 

    //Create the psTimers java array
    jintArray psTimers;
    psTimers = env->NewIntArray(N_PS_TIMES);

    if(psTimers == NULL) {
      printf("psTimers -> java array failed\n");
    }      

    jint tempTimes[N_PS_TIMES];

    for(int i = 0; i < N_PS_TIMES; i++)
      {
	tempTimes[i] = polyS->psTimers[i];
      }

    env->SetIntArrayRegion(psTimers, 0, N_PS_TIMES, tempTimes); 

    //Create the psUser java array
    //Create a ProcessStat class object
    jclass statClass = env->FindClass("com/model/ProcessStat");

    if (statClass == 0) printf("NULL RETURNED in FindClass()\n");

    printf("Sizeof statClass = %d\n", (int)sizeof(statClass) );

    jmethodID constructorMethodID;

    //get the constructor
    constructorMethodID = env->GetMethodID(statClass,
					      "<init>","(Ljava/lang/String;[JI[II[II)V");

    if (constructorMethodID == 0) 
      printf("NULL RETURNED TO constructorMethodID\n"); 

    jstring message = env->NewStringUTF(fileNamePtr);

    jobject statObj;

    //Create new ProcessStat object

    statObj = env->NewObject(statClass, constructorMethodID, message, psCounters,
				N_PS_COUNTERS, psSizes, N_PS_SIZES, psTimers, N_PS_TIMES);

    //return statObj;
}

list <string> getProcessFiles(char *dir)
{
  DIR *dirPtr;
  list <string> entryList;
  struct dirent *entryPtr;

  if((dirPtr = opendir(dir)) == NULL)
    {
      printf("Cannot open directory\n");
    }
  else
    {
      while (entryPtr = readdir (dirPtr))  //Read each entry in the directory
	{
	  char *entryName = entryPtr->d_name;
	  char firstC = entryName[0];
	  
	  /* Store only file names that begins with p. This to ignore the .. and
	     . entries in unix folders */
	  
	  if(firstC =='p') 
	    {
	      entryList.push_front(entryPtr->d_name);
	    } 
	}

      (void) closedir (dirPtr);
    } 

  return entryList;
}
/* Returns the directory of PolyMl statistics data
 */

char* getPolyDir()
{
  char *homeDir = getenv("HOME");
  char *polyFolder = "/.polyml/";

  if(homeDir == NULL)
    {
      printf("No home directory available\n");
    }

  char *polyDir = (char*)malloc(strlen(homeDir) + strlen(polyFolder) + 1);

  sprintf(polyDir, "%s%s", homeDir, "/.polyml/");

  return polyDir;
}


